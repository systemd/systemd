<!DOCTYPE html>
<!-- SPDX-License-Identifier: LGPL-2.1-or-later -->
<html>
<head>
        <title>Journal</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<link rel="icon" type="image/svg+xml" href="favicon.svg" />
	<link rel="alternate icon" href="favicon.ico" />
        <style type=text/css>
                div#divlogs, table#details {
                        font-family: monospace;
                        font-size: 7pt;
                        background-color: #ffffff;
                        padding: 1em;
                        margin: 2em 0em;
                        border-radius: 10px 10px 10px 10px;
                        border: 1px solid threedshadow;
                }
                div#divlogs {
                        white-space: nowrap;
                        overflow-x: scroll;
                }
                table#details {
                        display: none;
                }
                div#divlogs {
                        display: block;
                }
                body {
                        background-color: #ededed;
                        color: #313739;
                        font: message-box;
                        margin: 3em;
                }
                td.timestamp {
                        text-align: right;
                        border-right: 1px dotted lightgrey;
                        padding-right: 5px;
                }
                td.process, td.hostname {
                        border-right: 1px dotted lightgrey;
                        padding-left: 5px;
                        padding-right: 5px;
                }
                .hide_hostname td.hostname {
                        display: none;
                }
                td.message {
                        padding-left: 5px;
                }
                td.message > a:link, td.message > a:visited {
                        text-decoration: none;
                        color: #313739;
                }
                td.message-error {
                        padding-left: 5px;
                        color: red;
                        font-weight: bold;
                }
                td.message-error > a:link, td.message-error > a:visited {
                        text-decoration: none;
                        color: red;
                }
                td.message-highlight {
                        padding-left: 5px;
                        font-weight: bold;
                }
                td.message-highlight > a:link, td.message-highlight > a:visited {
                        text-decoration: none;
                        color: #313739;
                }
                td > a:hover, td > a:active {
                        text-decoration: underline;
                        color: #c13739;
                }
                #tablelogs td, #details td {
                        white-space: pre;
                }
                table#tablelogs, table#details {
                        font-size: 7pt;
                        border-collapse: collapse;
                        width: 100%;
                }
                table#details tr:nth-child(even) {
                        background-color: #ededed
                }
                td.field {
                        text-align: right;
                        border-right: 1px dotted lightgrey;
                        padding-right: 5px;
                }
                td.data {
                        padding-left: 5px;
                }
                div#keynav {
                        text-align: center;
                        font-size: 7pt;
                        color: #818789;
                        padding-top: 2em;
                }
                span.key {
                        font-weight: bold;
                        color: #313739;
                }
                div#buttonnav {
                        text-align: center;
                }
                #buttonnav button {
                        font-size: 18pt;
                        font-weight: bold;
                        width: 2em;
                        height: 2em;
                }
                div#filternav {
                        text-align: center;
                }
                select {
                        min-width: 20em;
                }
                input[type="checkbox"]:checked ~ td {
                        background-color: #ededed;
                }
                input[type=range] {
                        vertical-align: middle;
                }
                input[name=follow] {
                        display: none;
                }
                input[type=checkbox] {
                        display: none;
                }
                input[name=follow] + button#followbtn::before {
                        content: "\25B6";
                }
                input[name=follow]:checked + button#followbtn::before {
                        content: "\25AE\25AE";
			font-stretch: extra-condensed;
                }
                input[name=follow]:checked + button#followbtn ~ button {
                        opacity: 0.5;
                }
                input[type=number] {
                        border-width: 0;
                        font-weight:bold;
                        background:none;
                        width: 3em;
                        text-align: center;
                        -webkit-appearance: none;
                        -moz-appearance: textfield;
                        appearance: none;
                }
                .errorbox {
                        display: block;
                        border-radius: 10px 10px 10px 10px;
                        border: 1px solid #f00;
                        background-color: #faa;
                        text-align: center;
                        margin-top: 10px;
                }
                a {
                        color: #313739;
                }
                button.icon {
                        opacity: 0;
                        margin: 0;
                        border: 0;
                        background: none;
                }
                #details td:hover .icon {
                        opacity: 1;
                }
                #details .icon {
                        padding: 0 4px;
                        text-decoration: none;
                }
                button.remove {
                        font-weight: bold;
                        color: #f00;
                }
                #filters p:hover .icon {
                        opacity: 1;
                }
        </style>
</head>
<body>
        <h1>Filters</h1>
        <form name="control" method="get">
        <div id="filters"></div>
        <select name="filterList" onchange="addFilter(this.value);"></select>

        <h1>Events</h1>
        <div id="showing">Showing <b><input type="number" name="lines" min="10" max="1000" value="50" step="10" onchange="entriesLoad();" /></b> entries.</div>
        <div id="buttonnav">
                <button id="more" type="button" onclick="entriesMore();" title="More Entries"/>+</button>
                <button id="less" type="button" onclick="entriesLess();" title="Fewer Entries"/>-</button>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <button id="head" onclick="entriesLoadHead();" title="First Page">&#8676;</button>
                <button id="previous" type="button" onclick="entriesLoadPrevious();" title="Previous Page"/>&#8592;</button>
                <input type="checkbox" name="follow" checked />
                <button id="followbtn" type="button" onclick="toggleFollow();" title="Pause"></button>
                <button id="copypos" type="button" onclick="copyPosition();" title="Copy URL for current view to clipboard">&#128203;</button>
                <button id="next" type="button" onclick="entriesLoadNext();" title="Next Page"/>&#8594;</button>
                <button id="tail" type="button" onclick="entriesLoadTail();" title="Last Page"/>&#8677;</button>
        </div>
        <div id="keynav">
                <span class="key">g</span>: First Page &nbsp;&nbsp;&nbsp;&nbsp;
                <span class="key">&#8592;, k, BACKSPACE</span>: Previous Page &nbsp;&nbsp;&nbsp;&nbsp;
                <span class="key">p, SPACE</span>: Play/Pause &nbsp;&nbsp;&nbsp;&nbsp;
                <span class="key">&#8594;, j</span>: Next Page &nbsp;&nbsp;&nbsp;&nbsp;
                <span class="key">G</span>: Last Page &nbsp;&nbsp;&nbsp;&nbsp;
                <span class="key">+</span>: More entries &nbsp;&nbsp;&nbsp;&nbsp;
                <span class="key">-</span>: Fewer entries
        </div>
        <div id="connectionError" class="errorbox" style="display:none;" onclick="hideBlock(this);">Connection failed or interrupted. <a href="#" onclick="entriesLoad();">Retry</a>.</div>
        <div id="noEntriesError" class="errorbox" style="display:none;" onclick="hideBlock(this);">No entries found. <a href="#" onclick="entriesLoad();">Load previous page</a>.</div>
        <div id="filterErrors" class="errorbox" style="display:none;" onclick="hideBlock(this);">Search results may differ from expected :<br/></div>
        <div id="cantFindEntriesError" class="errorbox" style="display:none;" onclick="hideBlock(this);"></div>
        <div id=divlogs>
                <table id=tablelogs>
                        <tbody id=journal></tbody>
                </table>
        </div>
        <table id="details"></table>
        </form>
        <script type=text/javascript>
                const journal = document.getElementById("journal");
                const controlForm = document.forms.control;
                const pathname = new URL(window.location.href).pathname;
                const documentPath = pathname.substring(0, pathname.lastIndexOf("/"));
                const oldDocumentPath = "http://journal.local/";
                const tableDetails = document.getElementById("details");

                function htmlElement(tagName, attributes = {}, text = "") {
                        let element = document.createElement(tagName);
                        for (let [name, value] of Object.entries(attributes))
                                element.setAttribute(name, value);

                        if (text)
                                element.appendChild(document.createTextNode(text));

                        return element;
                }
                function clickableIcon(content, callback, title, clazz = "") {
                        const icon = htmlElement("button", {class: "icon " + clazz, title: title}, content);
                        icon.addEventListener("click", callback);
                        return icon;
                }

                function hideBlock(block) {
                        block.style.display = "none";
                }
                function connectionError() {
                        document.getElementById("connectionError").style.display = "block";
                }
                function noEntriesError() {
                        document.getElementById("noEntriesError").style.display = "block";
                }
                function entriesErrorClear() {
                        document.getElementById("connectionError").style.display = "none";
                        document.getElementById("noEntriesError").style.display = "none";
                }
                function filterNoValueError(filterName, filterValue) {
                        const filterErrorsBlock = document.getElementById("filterErrors");
                        filterErrorsBlock.appendChild(document.createTextNode("For field " + filterName + ", value " + filterValue + " does not exist anymore."));
                        filterErrorsBlock.appendChild(htmlElement("br"));
                        filterErrorsBlock.style.display = "block";
                }
                let failedEntries = [];
                function cantFindEntriesError(cursor) {
                        if (!failedEntries.includes(cursor))
                                failedEntries.push(cursor);

                        const cantFindEntriesErrorBlock = htmlElement("div", {"id":"cantFindEntriesError", "class": "errorbox"});
                        cantFindEntriesErrorBlock.appendChild(document.createTextNode("Unable to find entr" + (failedEntries.length > 1 ? "ies ":"y ")));
                        function linkAndJoin(cursor, index, array) {
                                const link = htmlElement("a", {"href":"?entry="+encodeURIComponent(cursor)+"&cursor="+encodeURIComponent(cursor), "target":"_blank"}, "#" + cursor.substr(-6));
                                link.addEventListener("click", event => {event.stopPropagation();});
                                cantFindEntriesErrorBlock.appendChild(link);
                                if (index < array.length - 2)
                                        cantFindEntriesErrorBlock.appendChild(document.createTextNode(", "));
                                else if (index == array.length - 2)
                                        cantFindEntriesErrorBlock.appendChild(document.createTextNode(" and "));

                        }
                        failedEntries.forEach(linkAndJoin);
                        cantFindEntriesErrorBlock.addEventListener("click", event => { hideBlock(event.currentTarget); });

                        let originalNode = document.getElementById("cantFindEntriesError");
                        originalNode.parentNode.replaceChild(cantFindEntriesErrorBlock, originalNode);
                }

                class Filter {
                        constructor(name) {
                                this.name = name;
                                this.loaded = false;
                                this.label = name.replace(/_/g, " ").trim().toLowerCase();
                                this.label = this.label[0].toUpperCase() + this.label.substring(1);
                                this.container = document.getElementById("filters");
                        }
                        display(values, selectedValue = null) {
                                let htmlNode = null;
                                if (selectedValue && !values.includes(selectedValue)) {
                                        filterNoValueError(this.label, selectedValue);
                                        selectedValue = null;
                                }
                                if (values.length == 1) {
                                        htmlNode = htmlElement("b", {}, values[0]);
                                        htmlNode.appendChild(htmlElement("input", {"type": "hidden", "name": this.name, "value" : values[0]}));
                                } else {
                                        htmlNode = htmlElement("select", {"name": this.name});
                                        htmlNode.addEventListener("change", entriesLoad);
                                        htmlNode.add(new Option("All", ""));
                                        values.forEach(value => htmlNode.add(new Option(value)));
                                        htmlNode.value = selectedValue ? selectedValue : "";
                                }
                                document.getElementById(this.name).appendChild(htmlNode);
                                return values;
                        }
                        labelBlock () {
                                const block = htmlElement("p", {"id": this.name});
                                const name = this.name;
                                const label = this.label;
                                block.appendChild(clickableIcon("Ã—", () => {removeFilter(name); }, "Remove filter on " + label, "remove"));
                                block.appendChild(document.createTextNode(this.label + " : "));
                                return block;
                        }
                        load(selectedValue = null) {
                                this.container.appendChild(this.labelBlock());
                                this.loaded = true;
                                return fetch(documentPath + "/fields/" + encodeURIComponent(this.name))
                                .then(response => response.text())
                                .then(text => text.split("\n").filter(s => s != ""))
                                .then(values => this.display(values, selectedValue));
                        }
                        loadOrSetValue(value) {
                                if (this.loaded) {
                                        this.setValue(value);
                                        return Promise.resolve(true);
                                } else {
                                        return this.load(value);
                                }
                        }
                        unload() {
                                document.getElementById(this.name).remove();
                                this.loaded = false;
                        }
                        setValue(value) {
                                controlForm[this.name].value = value;
                        }
                        valueFromSearchParams(searchParams) {
                                return searchParams.get(this.name);
                        }
                        appendToFormData(formData) {
                                if (!this.loaded)
                                        return;

                                const val = controlForm[this.name].value;
                                if (val == null || val == "")
                                        return;

                                formData.append(this.name, val);
                        }
                }
                // Let's define some specific filters :
                let filters = {
                        "PRIORITY": new Filter("PRIORITY"),
                        "_HOSTNAME": new Filter("_HOSTNAME"),
                        "MESSAGE": new Filter("MESSAGE"),
                        "time": new Filter("time")
                }
                filters.PRIORITY.priorities = {
                        "0": "Emergency",
                        "1": "Alert",
                        "2": "Critical",
                        "3": "Error",
                        "4": "Warning",
                        "5": "Notice",
                        "6": "Informational",
                        "7": "Debug"
                };
                filters.PRIORITY.label = "Minimum priority";
                function onPriorityChange() {
                        document.getElementById("priority_label").textContent = filters.PRIORITY.priorities[this.value];
                        entriesLoad();
                }
                filters.PRIORITY.load = function(selectedValue = 7) {
                        const block = this.labelBlock();
                        const input = htmlElement("input", {"name": this.name, "type":"range", "min": 0, "max": 7, "value":selectedValue});
                        input.addEventListener("change", onPriorityChange);
                        block.appendChild(input);
                        block.appendChild(document.createTextNode(" ("));
                        block.appendChild(htmlElement("b", {"id": "priority_label"}, this.priorities[selectedValue]));
                        block.appendChild(document.createTextNode(")"));
                        this.container.appendChild(block);
                        this.loaded = true;
                        return Promise.resolve(true);
                }
                filters.PRIORITY.appendToFormData = function(formData) {
                        if (!this.loaded || controlForm[this.name].value == 7)
                                return;

                        for (let i = 1; i <= controlForm[this.name].value; i++)
                                formData.append(this.name, i);
                }
                filters._HOSTNAME.load = function(selectedValue = null) {
                        this.container.appendChild(this.labelBlock());
                        this.loaded = true;
                        return fetch(documentPath + "/fields/_HOSTNAME")
                        .then(response => response.text())
                        .then(text => text.split("\n").filter(s => s != ""))
                        .then(values => this.display(values, selectedValue))
                        .then(function (values) { if (values.length <= 1) journal.classList.add("hide_hostname")});
                }
                filters.MESSAGE.placeholder = "Search message text";
                filters.MESSAGE.load = function(selectedValue = null) {
                        this.loaded = true;
                        const block = this.labelBlock();
                        if (selectedValue === null)
                                selectedValue = "";

                        const input = htmlElement("input", {"type": "text", "value":selectedValue, "placeholder": this.placeholder, "name": this.name});
                        input.addEventListener("change", entriesLoad);
                        block.appendChild(input);
                        this.container.appendChild(block);
                        return Promise.resolve(true);
                }
                filters.time.onMachineInfoReceive = function(machineInfo) {
                        if (!("time_date" in controlForm && "cutoff_from_realtime" in machineInfo && "cutoff_to_realtime" in machineInfo))
                                return;

                        const minDate = new Date(machineInfo.cutoff_from_realtime / 1000);
                        const maxDate = new Date(machineInfo.cutoff_to_realtime / 1000);
                        controlForm.time_date.setAttribute("min", minDate.toLocaleDateString("fr-ca"));
                        controlForm.time_date.setAttribute("max", maxDate.toLocaleDateString("fr-ca"));
                }
                filters.time.load = function (value = null) {
                        this.loaded = true;
                        const block = this.labelBlock();
                        const inputDate = htmlElement("input", {"type": "date", "name": "time_date"});
                        inputDate.addEventListener("change", onTimeChange);
                        const inputTime = htmlElement("input", {"type": "time", "name": "time_time", "step": 1});
                        inputTime.addEventListener("change", onTimeChange);
                        block.appendChild(inputDate);
                        block.appendChild(inputTime);
                        this.container.appendChild(block);
                        if (value)
                                this.setValue(value);

                        fetch(documentPath + "/machine")
                        .then(response => response.json())
                        .then(filters.time.onMachineInfoReceive);
                        return Promise.resolve(true);
                }
                filters.time.valueFromSearchParams = function (searchParams) {
                        if (searchParams.has("time_date") && searchParams.has("time_time")) {
                                let date = new Date(searchParams.get("time_date") + " " + searchParams.get("time_time"));
                                return (date.toString() == "Invalid Date" ? "" : date);
                        } else {
                                return null;
                        }
                }
                filters.time.setValue = function (dateTime) {
                        if (dateTime == null) {
                                controlForm.time_time.value = "";
                                controlForm.time_date.value = "";
                        } else {
                                controlForm.time_date.value = dateTime.toLocaleDateString("fr-ca");
                                controlForm.time_time.value = dateTime.toLocaleTimeString("en-gb");
                        }
                }
                filters.time.appendToFormData = function() {}
                filters.time.toMicroTimestamp = function() {
                        if (!this.loaded || controlForm.time_time.value == "" || controlForm.time_date.value == "")
                                return null;

                        const date = new Date(controlForm.time_date.value + " " + controlForm.time_time.value);
                        const timestamp = date.getTime();

                        if (isNaN(timestamp))
                                return null;
                        else
                                return timestamp * 1000;
                }
                filters.time.isValidDate = function () {
                        return this.toMicroTimestamp() !== null;
                }
                function setFilterList() {
                        controlForm.filterList.options.length = 0;
                        controlForm.filterList.add(new Option("filter on...", ""));
                        Object.keys(filters)
                        .filter(name => !filters[name].loaded)
                        .forEach(name => { controlForm.filterList.add(new Option(filters[name].label, filters[name].name)); });
                }
                function addFilter(name, value = null) {
                        filters[name].load(value);
                        setFilterList();
                }
                function removeFilter(name) {
                        filters[name].unload();
                        setFilterList();
                        entriesLoad();
                }

                function filtersSetup(fieldList) {
                        const definedFilters = Object.keys(filters);
                        fieldList
                        .filter(name => !definedFilters.includes(name))
                        .forEach(name => filters[name] = new Filter(name));
                        return filters;
                }
                function hiddenSelectedEntries(cursorArray) {
                        const selectedEntriesDiv = htmlElement("div", {"id": "hiddenSelectedEntries", "style": "display:none;"});
                        cursorArray
                        .filter((cursor, index, array) => array.indexOf(cursor) == index)
                        .forEach(cursor => selectedEntriesDiv.appendChild(htmlElement("input", {"type":"hidden", "name": "entry", "value":cursor})));
                        return selectedEntriesDiv
                }
                function clearHiddenSelectedEntries() {
			const hiddenDiv = document.getElementById("hiddenSelectedEntries");
                        if (hiddenDiv !== null)
                                controlForm.removeChild(hiddenDiv);
                }
                function controlFormFromQueryParameters(queryParameters) {
                        if (queryParameters.has("lines"))
                                controlForm.lines.value = queryParameters.get("lines");

                        if (queryParameters.has("cursor"))
                                controlForm.appendChild(htmlElement("input", {type: "hidden", name: "cursor", value: queryParameters.get("cursor")}));

                        if (queryParameters.has("offset"))
                                controlForm.appendChild(htmlElement("input", {type: "hidden", name: "offset", value: queryParameters.get("offset")}));

                        controlForm.follow.checked = queryParameters.has("follow");
                        controlForm.appendChild(hiddenSelectedEntries(queryParameters.getAll("entry")));

                        let filterPromises = [];
                        for (const filter of Object.values(filters)) {
                                let value = filter.valueFromSearchParams(queryParameters);
                                if (value !== null)
                                        filterPromises.push(filter.load(value));
                        }
                        setFilterList();
                        return filterPromises;
                }
                function defaultFilters(fieldList) {
                        let promises = ["_HOSTNAME", "SYSLOG_IDENTIFIER", "PRIORITY"]
                                .filter(f => fieldList.includes(f))
                                .map(field => filters[field].load());

                        promises.push(filters.time.load());
                        setFilterList();
                        return promises;
                }
                function detailsSetup(fields) {
                        function detailsFieldLine(name) {
                                let line = htmlElement("tr", {"id": "field_" + name});
                                line.appendChild(htmlElement("td", {}, name));
                                return line;
                        }

                        tableDetails.appendChild(detailsFieldLine("__REALTIME_TIMESTAMP"));
                        for (let field of Object.values(fields))
                                tableDetails.appendChild(detailsFieldLine(field.name));

                        tableDetails.appendChild(detailsFieldLine("__MONOTONIC_TIMESTAMP"));
                        tableDetails.appendChild(detailsFieldLine("__CURSOR"));
                }
                function formSetup(fieldList) {
                        detailsSetup(filtersSetup(fieldList));

                        let queryParameters = (new URL(window.location)).searchParams;
                        if (queryParameters.toString().length == 0)
                                return Promise.all(defaultFilters(fieldList))
                                        .then(entriesLoad);
                        else
                                return Promise.all(controlFormFromQueryParameters(queryParameters))
                                        .then(entriesLoad)
                                        .then(clearHiddenSelectedEntries);
                }

                let stream;
                function toggleFollow() {
                        const follow = controlForm.follow;
                        follow.checked = !follow.checked;
                        document.getElementById("followbtn").title = follow.checked ? "Pause" : "Play";
                        if (follow.checked) {
                                clearPosition();
                                entriesLoad();
                        } else {
                                fixPosition();
                        }
                }
                function startStream(url) {
                        stream = new EventSource(url);
                        stream.addEventListener('error', err => {
                                fixPosition();
                                connectionError();
                                console.error("EventSource failed:", err);
                        });
                        stream.addEventListener('message', event => entryDisplay(event.data));
                }
                function stopStreamIfNeeded() {
                        if (typeof stream !== "undefined" && stream.readyState != 2)
                                stream.close();
                }
                window.onbeforeunload = stopStreamIfNeeded;

                function journalClear() {
                        while (journal.lastChild)
                                journal.removeChild(journal.lastChild);

                        detailsClear();
                        entriesErrorClear();
                }
                function firstCursor() {
                        if (journal.firstChild == null || typeof journal.firstChild.getAttribute == "undefined")
                                return null;

                        return journal.firstChild.dataset.cursor;
                }
                function lastCursor() {
                        if (journal.lastChild == null || typeof journal.lastChild.getAttribute == "undefined")
                                return null;

                        return journal.lastChild.dataset.cursor;
                }
                function setPosition(cursor = null, offset = null) {
                        function setOrRemove(entity, value) {
                                if (value === null) {
                                        if (entity in controlForm)
                                                controlForm.removeChild(controlForm[entity]);

                                        return;
                                }
                                if (entity in controlForm)
                                        controlForm[entity].value = value;
                                else
                                        controlForm.appendChild(htmlElement("input", {type: "hidden", name: entity, value: value}));
                                return;
                        }
                        controlForm.follow.checked = false;
                        stopStreamIfNeeded();
                        setOrRemove("cursor", cursor);
                        setOrRemove("offset", offset);

                        if (filters.time.loaded && (cursor !== null || offset !== null))
                                filters.time.setValue(null);
                }
                function fixPosition() {
                        if (!filters.time.isValidDate())
                                setPosition(firstCursor());
                }
                function clearPosition() {
                        if ("cursor" in controlForm)
                                controlForm.removeChild(controlForm.cursor);

                        if ("offset" in controlForm)
                                controlForm.removeChild(controlForm.offset);
                }
                function onTimeChange() {
                        if (!filters.time.isValidDate())
                                return;

                        setPosition(null, null);
                        detailsClear();
                        entriesLoad();
                }
                function getURLFromForm() {
                        let formData = new FormData();
                        Object.values(filters).forEach(filter => filter.appendToFormData(formData));

                        formData.append("lines", controlForm.lines.value);
                        if (controlForm.follow.checked)
                            formData.append("follow", "1");

                        return documentPath+"/entries?"+(new URLSearchParams(formData)).toString();
                }
                function setURL() {
                        const sp = new URLSearchParams(new FormData(controlForm));
                        const url = documentPath+"/browse?"+sp.toString();
                        history.pushState(url, "", url);
                }

                function formatBytes(u) {
                        if (u >= 1024*1024*1024*1024)
                                return (u/1024/1024/1024/1024).toFixed(1) + " TiB";
                        else if (u >= 1024*1024*1024)
                                return (u/1024/1024/1024).toFixed(1) + " GiB";
                        else if (u >= 1024*1024)
                                return (u/1024/1024).toFixed(1) + " MiB";
                        else if (u >= 1024)
                                return (u/1024).toFixed(1) + " KiB";
                        else
                                return u.toString() + " B";
                }
                function entryDisplay(entryJSON) {
                        const entry = JSON.parse(entryJSON);
                        if (entry == undefined || entry.MESSAGE == undefined || entry.__CURSOR == undefined)
                                return;

                        let priority;
                        if (entry.PRIORITY != undefined)
                                priority = parseInt(entry.PRIORITY);
                        else
                                priority = 6;

                        let clazz;
                        if (priority <= 3)
                                clazz = "message-error";
                        else if (priority <= 5)
                                clazz = "message-highlight";
                        else
                                clazz = "message";

                        const line = htmlElement("tr", {"data-cursor": entry.__CURSOR});

                        const checkbox = htmlElement("input", {type: "checkbox", name: "entry", value: entry.__CURSOR, "id": "chk-" + entry.__CURSOR, "data-entry": entryJSON});
                        checkbox.addEventListener("change", onEntrySelect);
                        line.appendChild(checkbox);

                        const ts = htmlElement("td", {"class": "timestamp"});
                        if (entry.__REALTIME_TIMESTAMP != undefined) {
                                const timestamp = new Date(parseInt(entry.__REALTIME_TIMESTAMP) / 1000);
                                ts.textContent = timestamp.toLocaleString();
                        }
                        line.appendChild(ts);

                        line.appendChild(htmlElement("td", {class: "hostname"}, entry._HOSTNAME));

                        const process = htmlElement("td", {class: "process"});

                        if (entry.SYSLOG_IDENTIFIER != undefined)
                                process.textContent = entry.SYSLOG_IDENTIFIER;
                        else if (entry._COMM != undefined)
                                process.textContent = entry._COMM;

                        if (entry._PID != undefined)
                                process.textContent += "[" + entry._PID + "]";
                        else if (entry.SYSLOG_PID != undefined)
                                process.textContent += "[" + entry.SYSLOG_PID + "]";

                        line.appendChild(process);

                        const message = htmlElement("td", {"class": clazz});
                        let messageText = "";
                        if (entry.MESSAGE == null)
                                messageText = "[blob data]";
                        else if (entry.MESSAGE instanceof Array)
                                messageText = "[" + formatBytes(entry.MESSAGE.length) + " blob data]";
                        else
                                messageText = entry.MESSAGE;

                        message.appendChild(htmlElement("label", {"for": "chk-" + entry.__CURSOR}, messageText));

                        line.appendChild(message);
                        journal.appendChild(line);
                        while (journal.childNodes.length > controlForm.lines.value)
                                journal.removeChild(journal.firstChild);
                }
                function entriesDisplay(entriesText) {
                        const entries = entriesText.split(/[\x1E\x0A]/).filter(t => t != "");
                        journalClear();

                        if (entries.length == 0)
                                return noEntriesError();

                        entries.forEach(entryDisplay);
                }
                function getRange() {
			const microTimestamp = filters.time.toMicroTimestamp();
                        if (microTimestamp !== null)
                                return "time=" + microTimestamp + "::" + controlForm.lines.value;

                        let range = "entries=";
                        if ("cursor" in controlForm)
                                range += controlForm.cursor.value;

                        if ("offset" in controlForm)
                                range += ":" + controlForm.offset.value;

                        range += ":" + controlForm.lines.value;
                        return range;
                }
                function entriesLoad() {
                        const url = getURLFromForm();
                        setURL();
                        if (controlForm.follow.checked) {
                                stopStreamIfNeeded();
                                journalClear();
                                startStream(url);
                                return Promise.resolve(true);
                        } else {
                                return fetch(url,
                                        {headers: new Headers({Range: getRange(), Accept: "application/json"})})
                                .then(response => response.text())
                                .then(entriesDisplay)
                                .then(selectEntries)
                                .then(() => { fixPosition(); setURL(); })
                                .catch(function (e) {
                                        connectionError();
                                        console.error("error getting " + url + ": " + e);
                                });
                        }
                }

                function entriesLoadNext() {
                        if (!controlForm.follow.checked) {
                                detailsClear();
                                setPosition(lastCursor(), 1);
                                return entriesLoad();
                        }
                }
                function entriesLoadPrevious() {
                        detailsClear();
                        setPosition(firstCursor(), -controlForm.lines.value);
                        return entriesLoad();
                }
                function entriesLoadHead() {
                        detailsClear();
                        setPosition("");
                        return entriesLoad();
                }
                function entriesLoadTail() {
                        if (!controlForm.follow.checked) {
                                detailsClear();
                                setPosition("", -controlForm.lines.value);
                                return entriesLoad();
                        }
                }
                function entriesMore() {
                        controlForm.lines.value = Math.max(10, Math.min(1000, Number(controlForm.lines.value)+10));
                        return entriesLoad();
                }
                function entriesLess() {
                        controlForm.lines.value = Math.max(10, Math.min(1000, Number(controlForm.lines.value)-10));
                        return entriesLoad();
                }
                function copyPosition() {
                        console.log(document.location.toString());
                        console.log(navigator.clipboard);
                        if (controlForm.follow.checked)
                                navigator.clipboard.writeText(document.location.toString()).catch(() => {console.error("aa");});
                }

                function entryRemove(index) {
                        Array.from(tableDetails.children).forEach(line => line.removeChild(line.children[index + 1]));
                }
                function selectEntry(cursor) {
                        const chk = document.getElementById("chk-" + cursor);
                        if (!chk) {
                                cantFindEntriesError(cursor);
                                return;
                        } else {
                                chk.checked = true;
                                entryShowDetails(JSON.parse(chk.dataset.entry), getSelectedIndex(cursor));
                        }
                }
                function unselectEntry(cursor) {
                        const chk = document.getElementById("chk-" + cursor);
                        if (chk && chk.checked) {
                                chk.checked = false;
                                entryRemove(getSelectedIndex(cursor));
                        }
                }
                function selectEntries() {
                        const entries = (new URL(window.location)).searchParams.getAll("entry");
                        if (entries.length) {
                                tableDetails.style.display = "block";
                                entries.forEach(selectEntry);
                        }
                }
                function getSelectedIndex(cursor) {
                        if (controlForm.entry instanceof HTMLInputElement)
                                return 0;

                        return Array.from(controlForm.entry)
                                .filter(e => e.checked || e.value == cursor)
                                .map(e => e.value)
                                .indexOf(cursor);
                }
                function onEntrySelect() {
                        const cursor = this.value;
                        let selectedCursors;
                        if (controlForm.entry instanceof HTMLInputElement)
                                selectedCursors = [cursor];
                        else
                                selectedCursors = Array.from(controlForm.entry)
                                        .filter(e => e.checked || e.value == cursor)
                                        .map(e => e.value);

                        const index = selectedCursors.indexOf(cursor);
                        setURL();
                        if (this.checked == false) {
                                if (selectedCursors.length == 1)
                                        tableDetails.style.display = "none";

                                entryRemove(index);
                        } else {
                                fixPosition();
                                tableDetails.style.display = "block";
                                return entryShowDetails(JSON.parse(this.dataset.entry), index);
                        }
                }
                function detailsFieldDisplay(entry, field, index) {
                        let data = "";
                        const cell = htmlElement("td", {"class": "data"});
                        if (entry.hasOwnProperty(field))
                                data = entry[field];

                        if (data == null)
                                data = "[blob data]";
                        else if (data instanceof Array)
                                data = "[" + formatBytes(data.length) + " blob data]";

                        if (field.endsWith("REALTIME_TIMESTAMP"))
                                data += " (" + (new Date(parseInt(data) / 1000)).toLocaleString() + "." + (data % 1000).toString().padStart(3, 0) + ")";

                        if (data) {
                                cell.appendChild(document.createTextNode(data));
                                if (field in filters)
                                        cell.appendChild(clickableIcon("ðŸ”Ž", () => { filters[field].loadOrSetValue(data).then(entriesLoad); }, "Search entries with the same value"));
                        }
                        tableDetails.children["field_"+field].children[index].insertAdjacentElement("afterend", cell);
                }
                function entryShowDetails(entry, index) {
                        entriesErrorClear();
                        if (index >= 0)
                                Array.prototype.concat(Object.keys(filters), ["__CURSOR", "__MONOTONIC_TIMESTAMP", "__REALTIME_TIMESTAMP"])
                                .forEach(field => detailsFieldDisplay(entry, field, index));
                }
                function detailsClear() {
                        tableDetails.style.display = "none";
                        document.getElementsByName("entry").forEach(radio => radio.checked = false);
                        Array.from(tableDetails.children).forEach(line => {
                                while (line.children.length > 1)
                                        line.removeChild(line.lastChild);
                        });
                }

                function onKeyUp(event) {
                        switch (event.keyCode) {
                                case 8:
                                case 37:
                                case 75:
                                        entriesLoadPrevious();
                                        break;
                                case 39:
                                case 74:
                                        entriesLoadNext();
                                        break;
                                case 71:
                                        if (event.shiftKey)
                                                entriesLoadTail();
                                        else
                                                entriesLoadHead();
                                        break;
                                case 107:
                                        entriesMore();
                                        break;
                                case 109:
                                        entriesLess();
                                        break;
                                case 32:
                                case 80:
                                        toggleFollow();
                                        break;
                        }
                }

                function installHandlers() {
                        document.onkeyup = onKeyUp;
                        controlForm.addEventListener("submit", event => {
                                event.preventDefault();
                                entriesLoad();
                                return false;
                        });
                }

                function initControlForm() {
                        fetch(documentPath+"/fields", {headers: new Headers({Accept: "application/json"})})
                        .then(response => response.text())
                        .then(text => text
                                .split("\n")
                                .filter(line => line != "")
                                .map(line => JSON.parse(line).field))
                        .then(formSetup);
                }

                initControlForm();
                installHandlers();
        </script>
</body>
</html>
